\chapter{Development}

\section{Contract 1: Native storage}
The first variant that will be developed stores all IP addresses in the blockchain natively. The advantage is that all infrastructure is outsourced to the blockchain, making the solution completely decentralized. The disadvantage is that high gas fees make this the most costly solution and that the scale is limited in that the Ethereum blockchain is not designed to store data in the Gigabyte range.

\section{Contract 2: Pointer to web resource}
The second variant of the smart contract works around the space constraints and the big cost of the first variant by storing the list of IP addresses on a web resource and pointing to that on the blockchain. The advantage is that it works on a much larger scale. The disadvantage is that a web server needs to be set up and a separate standard has to be established describing the format of the web resource. This solution is also more prone to connectivity issues and does not take advantage of the decentralization and immutability of the blockchain.

\subsection{Web resource}
When pointing to a web resource, the design of the architecture that is not on the blockchain needs to be considered. By storing a URL in the blockchain, it is already implied that the connection to the resource is made using HTTP(S), which is a suitable protocol for our needs. The format of the web resource pointed to could be in any format imaginable. There are a few properties which are desirable: 1. Portability: To increase the adoption of our solution, use an already existing format like XML, CSV or JSON. 2. Upgradeability: The format should be able to be developed further in the future to enable more features, with backwards compatibility (which is hard if the format is CSV-like). 3. Streamability: As one can expect these lists to become very large, it would be useful to design the format in a way that it can already be partially evaluated while not yet fully loaded. Downloading a resource fully will take time and it would be desirable to not have to load the full list into memory. This is easy with CSV, as the file can be read line by line, but hard with XML or JSON, which needs to be fully loaded in order to be valid.
This is a classic 'Pick two out of three'-scenario, as these properties are conflicting with each other.
Finally, it needs to be decided whether the web resource should be immutable or not. Immutable means that the content of the web page can never change. Additions or deletions to the list are not supported, if the list had to be updated, it would have to move to a different URL and the entry in the blockchain has to be updated as well. This is not only a bad thing, as otherwise the client who accesses the resource has to worry about checking for updates. A hash can be generated for an immutable file, which could be stored in the blockchain as well and allow the clients to validate that the list has not been altered since it was registered in the smart contract, which is more in the spirit of the blockchain. If an asset is immutable, it can be easily outsourced to a CDN, which are harder to take down using a DDoS attack.
In summary, immutability makes it slower (and potentially more expensive) to register changes, but also has advantages.

\section{Contract 3: Bloom filter}
The third variant of the smart contract is a standalone contract that solves the scalability issue by storing not the whole list of IP addresses but only limited information from which it can only be said with a likelihood whether an IP address was blocked. The bloom filter contract is a nice balance between leveraging the blockchain and using little space, however it gives up perfect accuracy.

\section{IPv6 support}

With IPv4 addresses being 32 bits long, only 232 combinations possible and the amount of free addresses is almost exhausted, we are currently in a transition phase from IPv4 to IPv6. Therefore it makes sense to support both formats. Two ways of supporting both IPv4 and IPv6 could be considered:
The first is to represent IPv4 addresses as IPv6 addresses. The most widespread format is defined in RFC 3493: 80 bits of zeros, 16 bits of ones and then the IPv4 address. For example: The IPv4 address \texttt{46.101.96.149} would be \texttt{0:0:0:0:0:ffff:2e65:6095} in IPv6 hex representation. In fact, this notation is supported by the Linux kernel and macOS natively, in a web browser \texttt{http://[::ffff:2e65:6095]} will display the same website as \texttt{http://46.101.96.149}.
The other option would be to use a flag indicating whether an address is IPv4 or IPv6. If mainly IPv4 addresses are stored in a contract, this would yield a space benefit.
Given that there is already a standardized notation for IPv4 in IPv6 format,this thesis is proceeding with the first option.

\section{IP verification}
IP verification in all variants of the smart contract, owners of destination IP addresses can store source IP addresses they want to be blocked in the smart contract. In order to establish trust, there should be a way to automatically verify the ownership of the destination IP addresses. This is a challenging task, as is explained in this section. Using certificates to validate IP ownerships in Solidity is currently not practical for at least two reasons.
It is a computationally expensive task that would require more gas than the gas limit allows and there is no implementation of certificate verification in Solidity. Certificate verification, as it is most commonly done with OpenSSL, would have to be ported ported to Solidity, which is complex.
There is however a proposal to add certificate validation on a language-level (Ethereum Improvement Proposal \#74\footnote{https://github.com/ethereum/EIPs/issues/74}). As of writing, the exact implementation is not clear, with parts of the community vouching for direct RSA signature verification, and other parts wanting BigInt Support which could then enable certificate validation.
Since everything in the blockchain is public including stored certificates and IP addresses, it is not required that certificates are validated in Solidity, it can be done off the blockchain.
The second challenge is obtaining a certificate. As there is no way to mathematically or logically prove that somebody is the owner of an IP (it can be spoofed), the certificate process of domains could be applied to IPs: There are Certificate Authorities (CA) who verify and validate the ownership of a domain. CAs need to make investments in establishing a system that securely validates a domain and manages the certificates that are issued. CAs need to fulfill a wide range of requirements \cite{BaselineRequirements} to be considered reputable and be included in the root key store of operating system and browser vendors. nearly all CAs for domains issue certificates for a fee or need to generate revenue by sponsorships. Although it is technically possible to issue an SSL certificate for an IP address, it is very uncommon. GlobalSign\footnote{https://support.globalsign.com/customer/portal/articles/1216536-securing-a-public-ip-address---ssl-certificates} is the only provider known to us that issues certificates for IP addresses, and requires that the IP is registered in the RIPE database.
A system that currently exists for domain could be introduced by the industry for IP addresses, but is very complicated and defeats the purpose of using the blockchain as the original idea was to remove the need for additional infrastructure.

\section{Validating Smart contracts during development}
Developing a smart contract requires a compiler and a blockchain on which the developer can execute the smart contract. A compiler, such as solc\footnote{https://github.com/ethereum/solidity}, will warn about syntax errors and does not compile invalid Solidity code, indicating to the developer that there is an error in the code. While compilers provide a first layer of assurance by only compiling valid contracts with valid syntax, it is still possible to write code with bugs and security vulnerabilities. As with any software, developers need a workflow which allows them to test their changes fast and efficiently. The main Ethereum blockchain is unsuitable for validating the correctness of the code manually. There are significant costs to deploy a contract to the blockchain, also it is not capable of giving the developer immediate feedback because of transaction processing times. It is also frowned upon to use the main blockchain for testing purposes, as all network participants need to download all blocks. This is not the case in the testnet, which is a separate blockchain for testing purposes. Even better, there is a test framework called TestRPC that makes it possible to set up a local blockchain for testing. Using TestRPC, it is possible to simulate deployments and transactions of smart contracts with no confirmation delay. Out of the box, TestRPC sets up multiple Ethereum accounts, so it easy to switch the message sender address and test whether the security features of the developed smart contract are working as desired. This makes TestRPC the ideal blockchain for developing.
In addition to manual testing, the robustness should be validated by unit tests, just like in any other piece of software. This allows to automatically validate that all assertions are still true when a change is introduced to the contract. A robust contract should have unit tests validating that normal use of the contract features result in correct behavior, as well as edge cases and abuse of the contract features handled correctly. Examples of that are: Calling a function without permission, calling a function more often than expected, calling a function with unexpected arguments, such as null arguments, wrong types or a big payload.
I have used TestRPC, the Javascript "solc" compiler, and the "ava" testing framework to set up a test environment. Each test is completely atomic and independent from other ones, that means that for each test, a separate TestRPC blockchain is created and the scenario is run on it. After the test is finished, the blockchain and the accounts get destroyed. This complete isolation of each test is good practice, as side-effects can be ruled out. With "ava", the tests can be run in parallel, making it faster to run the whole test suite. However, there are many other generic test frameworks that work as well and have their own advantages and disadvantages. One interesting framework is Truffle\footnote{http://truffleframework.com/}, which provides helpers for developing and testing Solidity contracts. Truffle tries to make the process described in this section easier and looks very promising, but is still in beta. For the reason that the framework is still very much in development and changing, and that I have only discovered it after already having a solution working, I did not use it.
For real-world smart contract applications, testing is not enough, critical contracts should be audited by computer security professionals before being deployed. As the aim of this thesis is to document a proof-of-concept DDoS mitigation application, no audit will be conducted.

\section{Security considerations with Solidity}
Code vulnerabilities are more common in Ethereum than in other environments. The whole blockchain data is public, and serious contracts are made open source in order to create trust for the people who use it. Therefore applications are auditable and bugs are more likely to be found.The application must also regulate itself and can in most cases not recover from an attack.
In addition to that, the language Solidity aims to have a syntax similar to JavaScript and is therefore quite loose with enforcing the correct type. Static code analysis tools (such as Solium) are also not yet up to par with other languages.
In this section, some common "traps" that can lead to security exploits will be explained, partially taken from a list compiled by the co-founder of Ethereum \cite{ThinkingAboutSmartContractSecurity}.

\subsection{Constructor naming exploit}
Simple human mistakes can lead to the contract being vulnerable. The 'Rubixi' contract has a different constructor name than contract name. Therefore the constructor does not get called on deployment, but can be called as a transaction. If done so, the caller of the transaction becomes the owner of the contract. Because of more unfortunate design of the contract, the bug became not immediately apparent and the Solidity contract was correct.

\input{snippets/rubixi.tex}

\subsection{Public data}
A misconception is that stored data can be made private on the blockchain. A rock-paper-scissor contract which people used for gambling turned out to have a trivial flaw where the first move could be seen - rock would have the value \texttt{0x60689557} and scissor and paper have a different one.
The main takeaway is that in our case, the stored IP addresses will be public (although maybe obfuscated) to everybody. Even attackers can determine the list of IPs that are blocked. The contract should be created in a way that minifies the usefulness for attackers, for example the pattern of the IPs should not make the way how IPs are being blocked predictable.

\subsection{Loops}
The section "Security Considerations" of the Solidity documentation warns about loops that have a non-fixed amount of iterations. With a high number of iterations, the block gas limit could be reached and according to the Solidity documentations "cause the complete contract to be stalled at a certain point". In the reference contract, the function blockIPv4() has a loop whose amount of iterations are dependant of a transaction argument. The contract has to be tested with a big payload and a solution needs to be developed.
Furthermore, even for constant functions (which are executed locally and have no gas limit), there can be bugs. If, in the reference contract there would be a slight change:

\input{snippets/loop-bug.tex}

a bug would be introduced. \texttt{var} would be interpreted as \texttt{uint8}, and if there are more than 255 entries in the \texttt{drop\_src\_ipv4} array, there would be an overflow leading to an infinite loop.
This bug can be simply avoided by disallowing \texttt{var} in the code or by being aware of the issue.


\subsection{Re-Entry bugs using .call()}

The \texttt{.call()} method in Solidity is dangerous as it can execute code from external contracts. This weakness was first exploited in the DAO smart contract, which had over 50 million USD stored in it. The main takeaway from this incident is that \texttt{.call()} can call any public function, even the function from which it was called from, leading to recursion.
The following example is not safe:

\input{snippets/reentry-bug.tex}

Let's say that the balance of an account is 10 and that account calls the withdraw method. The account can execute arbitrary code when \texttt{msg.sender.call()} is called on line 3, so \texttt{withdraw()} can also be called again before line 4 of the above snippet is reached. An attacker could withdraw more than what its balance is. The vulnerability could be mitigated by using \texttt{.send()} instead of \texttt{.call()} in the example above.

\subsection{Call stack depth attack}

The call stack depth gets increased when a function calls another function, and if a function returns, the call stack depth gets decreased. A long call stack can be produced by excessive recursion. Solidity has a 1024 call stack depth limit - this means that Solidity could for example not compute the 1025th fibonacci number using recursion.
The deterministic depth limit of Solidity proves to be an attack vector. An attacker could craft a function that calls itself 1023 times and on the 1024th time calls another, vulnerable function, that stops execution as soon as a subfunction is called, because the maximum call stack size is reached. An attacker might force a function to only partially execute, which is a problem, if for example a withdraw function is composited of a subfunction that sends funds and a function that decreases the users balance.
The core development team of Ethereum wants to solve this problem on a language-level in EIP \#150 soon, therefore it will not be further discussed here.
