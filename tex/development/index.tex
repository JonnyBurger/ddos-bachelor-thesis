\chapter{Development}

\section{Contract 1: Native storage}
The first variant that will be developed stores all IP addresses in the blockchain natively. The advantage is that all infrastructure is outsourced to the blockchain, making the solution completely decentralized. The disadvantage is that high gas fees make this the most costly solution and that the scale is limited in that the Ethereum blockchain is not designed to store data in the Gigabyte range.

\section{Contract 2: Pointer to web resource}
The second variant of the smart contract works around the space constraints and the big cost of the first variant by storing the list of IP addresses on a web resource and pointing to that on the blockchain. The advantage is that it works on a much larger scale. The disadvantage is that a web server needs to be set up and a separate standard has to be established describing the format of the web resource. This solution is also more prone to connectivity issues and does not take advantage of the decentralization and immutability of the blockchain.

\subsection{Web resource}
When pointing to a web resource, the design of the architecture that is not on the blockchain needs to be considered. By storing a URL in the blockchain, it is already implied that the connection to the resource is made using HTTP(S), which is a suitable protocol for our needs.

The format of the web resource pointed to could be in any format imaginable. A syntax and a data structure has to be settled on. In this section, various aspects of the web resource format are discussed and a format will be developed.

Among the desirable properties that are:

\textbf{1. Portability:} An already common syntax like XML, CSV or JSON is desired because client libraries are already available and no further specifications are needed.

\textbf{2. Upgradeability:} The format of the web resource should be able to be developed further in the future to enable more features, with backwards compatibility. This is more difficult with a two-dimensional design like CSV, because the format can only be extended by adding more rows.

\textbf{3. Streamability:} As one can expect these lists to become very large, it is beneficiary to have the format in a way where it can already be partially evaluated while not yet fully loaded. Downloading a resource fully will take time and it is desirable to not have to load the full list into memory. This is easy with CSV, as the file can be read line by line, but hard with XML or JSON, which needs to be fully loaded in order to be valid.


These properties are conflicting with each other, as no mentioned format supports upgradeability or streamability at the same time.

Additionally, it needs to be decided whether the web resource should be immutable or not. Immutable means that the content of the web page can never change. Additions or deletions to the list are not supported, if the list had to be updated, it would have to move to a different URL and the entry in the blockchain has to be updated as well. This is not only a bad thing, as otherwise the client who accesses the resource has to worry about checking for updates.

A hash can be generated for an immutable file, which could be stored in the blockchain as well and allow the clients to verify that the list has not been altered since it was registered in the smart contract, which is more inline with the rest of architecture that resides in the blockchain. If an asset is immutable, it can be easily outsourced to a CDN, which is harder to deny using a DDoS attack.
In summary, immutability makes it slower and more expensive to register changes, but has the advantage of making it easy to manage changes.

\section{Contract 3: Bloom filter}

The third variant of the smart contract is a standalone contract that solves the scalability issue by using a bloom filter.

A bloom filter is a probabilistic data structure that is very space efficient. In the context of large amounts of IP addresses, it can be tested if an IP address has been inserted into the bloom filter beforehand with constant space requirements. False positives are possible, false negatives are not.

The bloom filter contract is a balance between leveraging the blockchain and using little space, however perfect accuracy cannot be guaranteed anymore.

\section{IPv6 support}

With IPv4 addresses being 32 bits long, only $ 2^{32} $ combinations possible and the amount of free addresses is almost exhausted \cite{IPv4Exhaustion}, there currently is a transition phase from IPv4 to IPv6. Therefore it makes sense to support both formats.

Two ways of supporting both IPv4 and IPv6 could be considered.
The first is to represent IPv4 addresses as IPv6 addresses. The most widespread format is defined in RFC 3493: 80 bits of zeros, 16 bits of ones, followed the IPv4 address. For example, the IPv4 address \texttt{46.101.96.149} would be \texttt{0:0:0:0:0:ffff:2e65:6095} in IPv6 hex representation. In fact, this notation is supported by the Linux kernel and macOS natively, in a web browser \texttt{http://[::ffff:2e65:6095]} will display the same website as \texttt{http://46.101.96.149}.

The other option would be to use a flag indicating whether an address is IPv4 or IPv6. If mainly IPv4 addresses are stored in a contract, this would yield a space benefit.
Given that there is already a standardized notation for IPv4 in IPv6 format,this thesis is proceeding with the first option.

\section{IP address ownership verification}
In all variants of the smart contract, owners of destination IP addresses can store source IP addresses they want to be blocked in the smart contract. In order to establish trust, there should be a way to automatically verify the ownership of the destination IP addresses. This is a challenging task, as is explained in this section. Using certificates to validate IP ownerships in Solidity is currently not practical for at least two reasons.

It is a computationally expensive task that would require more gas than the gas limit allows and there is no implementation of certificate verification in Solidity. Certificate verification, as it is most commonly done with OpenSSL, would have to be ported ported to Solidity, which is complex.
There is however a proposal to add certificate validation on a language-level \cite{EIP74}. As of writing, the exact implementation is not clear, with parts of the community vouching for direct RSA signature verification, and other parts wanting BigInt Support which could then enable certificate validation.

However, since everything in the blockchain is public including stored certificates and IP addresses, it is not required that certificates are validated in Solidity, it can also be done off the blockchain. 

The second challenge is obtaining a certificate. As there is no way to directly mathematically or logically prove that somebody is the owner of an IP (it can be spoofed), an indirect solution is required. It was considered that the certificate process of domains could be applied to IPs: There are Certificate Authorities (CA) who verify and validate the ownership of a domain.

CAs need to make investments in establishing a system that securely validates a domain and manages the certificates that are issued. CAs need to fulfill a wide range of requirements \cite{BaselineRequirements} to be considered reputable and be included in the root key store of operating system and browser vendors. Nearly all CAs for domains issue certificates for a fee or need to generate revenue by sponsorships.

Although it is technically possible to issue an SSL certificate for an IP address, it is very uncommon. GlobalSign \cite{GlobalSign} is the only provider known to us that issues certificates for IP addresses, and requires that the IP is registered in the RIPE database.

The same system that currently exists for domain owner verification could be introduced by the industry for IP addresses verification, but is very complicated and defeats the purpose of using the blockchain as the original idea was to remove the need for additional infrastructure.

\section{Validating Smart contracts during development}
Developing a smart contract requires a compiler and a blockchain on which the developer can execute the smart contract. A compiler, such as solc \cite{Solc}, will warn about syntax errors and does not compile invalid Solidity code, indicating to the developer that there is an error in the code.

While compilers provide a first layer of assurance by only compiling valid contracts with valid syntax, it is still possible to write code with bugs and security vulnerabilities. As with any software, developers need a workflow which allows them to test their changes fast and efficiently.

The main Ethereum blockchain is unsuitable for validating the correctness of the code manually. There are significant costs to deploy a contract to the blockchain, also it is not capable of giving the developer immediate feedback because of transaction processing times. It is also frowned upon to use the main blockchain for testing purposes, as all network participants need to download all blocks.

This is not the case in the Testnet, which is a separate blockchain for testing purposes. Still, the Testnet is a globally shared blockchain and is not perfect for development. Instead, a test framework called \texttt{TestRPC} that makes it possible to set up a local blockchain for testing is used. Using \texttt{TestRPC}, it is possible to simulate deployments and transactions of smart contracts with no confirmation delay. Out of the box, \texttt{TestRPC} sets up multiple Ethereum accounts, making it simple to switch the message sender address and test whether the access control features of the developed smart contract are working as desired. This makes \texttt{TestRPC} the ideal blockchain for developing.

In addition to manual testing, the robustness should be validated by unit tests, just like in any other piece of software. This allows to automatically validate that all assertions are still true when a change is introduced to the contract. A robust contract should include unit tests validating that normal use of the contract features result in correct behavior, as well as tests for edge cases and abuse of the contract features.

Examples of cases that should be tested are: Calling a function without permission, calling a function more often than expected, calling a function with unexpected arguments, such as null arguments, wrong types or a big payload.

\texttt{TestRPC}, the \texttt{solc-js} compiler, and the \texttt{ava} testing framework to set up a test environment. Each test is completely atomic and independent from other ones, that means that for each test, a separate \texttt{TestRPC} blockchain is created and the scenario is run on it. After the test is finished, the blockchain and the accounts get destroyed.

The complete isolation of each test is good practice, as side-effects can be ruled out. With \texttt{ava}, the tests can be run in parallel, making it faster to run the whole test suite. However, there are many other generic test frameworks that work just as well and have their own advantages and disadvantages.

One interesting specialized framework is Truffle \cite{Truffle}, which provides helpers for developing and testing Solidity contracts. Truffle attempts to make the process described in this section easier and looks very promising, but is still in beta. For the reason that the framework is still very much in development and changing, a generic testing framework was used.

For real-world smart contract applications, testing is not enough, critical contracts should be audited by computer security professionals before being deployed. As the aim of this thesis is to document a proof-of-concept DDoS mitigation application, no audit will be conducted.

\section{Security considerations with Solidity}
Code vulnerabilities are more common in Ethereum than in other environments. The whole blockchain data is public, and serious contracts are made open source in order to create trust for the people who use it. Therefore applications are auditable and bugs are more likely to be found.

The application must also regulate itself and can in most cases not recover from an attack with an update.

In addition to that, the language Solidity aims to have a syntax similar to JavaScript and is therefore quite loose with enforcing the correct type. External static code analysis tools such as Solium \cite{Solium} do not yet have as many rules included as comparable tools for more mature languages.

In this section, some common mistakes that can lead to security exploits will be explained, partially taken from a list compiled by the co-founder of Ethereum \cite{ThinkingAboutSmartContractSecurity} and based on real-word vulnerabilities.

\subsection{Constructor naming exploit}
Simple human mistakes can lead to the contract being vulnerable. The 'Rubixi' contract has a different constructor name than contract name. Therefore the constructor does not get called on deployment, but can be called as a transaction. If done so, the caller of the transaction becomes the owner of the contract. Because of more unfortunate design of the contract, the bug became not immediately apparent and the Solidity contract was correct.

\input{snippets/rubixi.tex}

\subsection{Public data}
A misconception is that stored data can be made private on the blockchain. A rock-paper-scissor contract which people used for gambling turned out to have a trivial flaw where the first move could be seen - rock would have the value \texttt{0x60689557} and scissor and paper have a different one.

The main takeaway is that the stored IP addresses will be public (although maybe obfuscated) to everybody. Even attackers can determine the list of IPs that are blocked. The contract should be created in a way that minimises the usefulness for attackers, for example the pattern of the IPs should not make the way how IPs are being blocked predictable.

\subsection{Loops}
The section "Security Considerations" of the Solidity documentation warns about loops that have a non-fixed amount of iterations. With a high number of iterations, the block gas limit could be reached and according to the Solidity documentations "cause the complete contract to be stalled at a certain point".

In the reference contract, the function \texttt{blockIPv4()} has a loop whose amount of iterations are dependant of a transaction argument. The contract has to be tested with a big payload and a solution needs to be developed.

Furthermore, even for constant functions (which are executed locally and have no gas limit), there can be bugs. If, in the reference contract there would be a slight change:

\input{snippets/loop-bug.tex}

a bug would be introduced. \texttt{var} would be interpreted as \texttt{uint8}, if there are more than 255 entries in the \texttt{drop\_src\_ipv4} array, an overflow leading to an infinite loop would happen.
This bug can be avoided by disallowing \texttt{var} in the code or by being aware of the issue.

\subsection{Re-Entry bugs using .call()}

The \texttt{.call()} method in Solidity is dangerous as it can execute code from external contracts. This weakness was first exploited in the DAO smart contract, which had over 50 million USD stored in it. The takeaway from the incident is that \texttt{.call()} can call any public function, even the function from which it was called from, leading to recursion.
The following example is not safe:

\input{snippets/reentry-bug.tex}

For illustrating the vulnerability, consider that the balance of an account is 10 and that account calls the withdraw method. The account can execute arbitrary code when \texttt{msg.sender.call()} is called on line 3, so \texttt{withdraw()} can also be called again before line 4 of the above snippet is reached. An attacker could withdraw more than what its balance is. The vulnerability could be mitigated by using \texttt{.send()} instead of \texttt{.call()} in the example above.

\subsection{Call stack depth attack}

The call stack depth gets increased when a function calls another function, and if a function returns, the call stack depth gets decreased. A long call stack can be produced by excessive recursion. Solidity has a 1024 call stack depth limit - this means that Solidity could for example not compute the 1025th fibonacci number using recursion.

The deterministic depth limit of Solidity proves to be an attack vector. An attacker could craft a function that calls itself 1023 times and on the 1024th time calls another, vulnerable function, that stops execution as soon as a subfunction is called, because the maximum call stack size is reached. 

An attacker might force a function to only partially execute, which is a problem, if for example a withdraw function is composited of a subfunction that sends funds and a function that decreases the users balance.
The core development team of Ethereum wants to solve this problem on a language-level in EIP \#150 \cite{EIP150} soon, therefore it will not be further discussed here.
