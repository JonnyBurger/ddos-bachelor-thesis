\chapter{Development}

In the following, three variants of a DDoS attack signaling protocol are being developed. For that, a smart contract is being written in the Soldity programming language \cite{Solc} for each variant. A smart contract strongly resembles a 'class' that is known from object-oriented programming. The following is a 'Hello World' smart contract from the Ethereum website (https://www.ethereum.org/greeter).

\input{snippets/greeter.tex}

Instead of the \texttt{class} keyword, solidity uses a \texttt{contract} keyword. Inheritance is possible using the \texttt{is} (rather than \texttt{extends} in Java) keyword. A contract can, like a class, be instantiated. The constructor is defined by the method within the contract that has the same name as the contract - in this case, \texttt{function greeter(string greeting)} is the constructor of \texttt{greeter}. Methods can be declared public or private. They are, like in Javascript, prefixed with the \texttt{function} keyword. A special type in Solidity is the \texttt{address} type, which can hold an 40-byte address of an Ethereum network user.

This Solidity code can be compiled to bytecode and deployed on a Ethereum blockchain. When deployed, the contract is stored in a block, alongside with other data that users committed to the Blockchain, and synced to all users of the network (downloading the complete public Ethereum Blockchain uses dozens of Gigabytes). Once the deployment is finished, Ethereum users can instantiate the smart contract. If they choose to do so, they  send a transaction to the Ethereum network and the instance of the contract is registered on the Blockchain. Methods can also be executed by sending a transaction to the Ethereum Blockchain.

In each method body, a \texttt{msg} global object is available, containing information about the transaction being executed, including \texttt{msg.sender} (an \texttt{address}), \texttt{msg.gas}, \texttt{msg.value} (for sending Ether).

In addition to that, a second global variable \texttt{block} gives information about the current block, including \texttt{block.number} and \texttt{block.timestamp}.

A constant method, like \texttt{function greet() constant returns (string)} is a special function that does not trigger a transaction. Instead, it is a getter function that only executes locally. Constant functions provide convienient interfaces for reading data, but all data should be considered public.

\section{IPv6 considerations}

With IPv4 addresses being 32 bits long, only $ 2^{32} $ combinations possible and the amount of free addresses is almost exhausted \cite{IPv4Exhaustion}, there currently is a transition phase from IPv4 to IPv6. Therefore it makes sense to support both formats.

An IPv4 address can be represented in IPv6 using a format that is defined RFC 3493: 80 bits of zeros, 16 bits of ones, followed the IPv4 address. For example, the IPv4 address \texttt{46.101.96.149} would be \texttt{0:0:0:0:0:ffff:2e65:6095} in IPv6 hex representation. This notation is supported by the Linux kernel and macOS natively, in a web browser \texttt{http://[::ffff:2e65:6095]} will display the same website as \texttt{http://46.101.96.149}.

This makes it possible to greatly simplify support for both IPv4 and IPv6, with no flag needed to indicate which version of the protocol is meant. All addresses are stored in a IPv6 format (using a \texttt{uint128} type) and if the bits 81-96 are all ones, it indicates that it is an IPv4 address.

\input{contract-1.tex}
\input{contract-2.tex}

\section{Contract 3: Bloom filter}

The third variant of the smart contract is a standalone contract that solves the scalability issue by using a bloom filter.

A bloom filter is a probabilistic data structure that is very space efficient. In the context of large amounts of IP addresses, it can be tested if an IP address has been inserted into the bloom filter beforehand with constant space requirements. False positives are possible, false negatives are not.

The bloom filter contract is a balance between leveraging the blockchain and using little space, however perfect accuracy cannot be guaranteed anymore.

\section{IP address ownership verification}
In all variants of the smart contract, owners of destination IP addresses can store source IP addresses they want to be blocked in the smart contract. In order to establish trust, there should be a way to automatically verify the ownership of the destination IP addresses. This is a challenging task, as is explained in this section. Using certificates to validate IP ownerships in Solidity is currently not practical for at least two reasons.

It is a computationally expensive task that would require more gas than the gas limit allows and there is no implementation of certificate verification in Solidity. Certificate verification, as it is most commonly done with OpenSSL, would have to be ported ported to Solidity, which is complex.
There is however a proposal to add certificate validation on a language-level \cite{EIP74}. As of writing, the exact implementation is not clear, with parts of the community vouching for direct RSA signature verification, and other parts wanting BigInt Support which could then enable certificate validation.

However, since everything in the blockchain is public including stored certificates and IP addresses, it is not required that certificates are validated in Solidity, it can also be done off the blockchain. 

The second challenge is obtaining a certificate. As there is no way to directly mathematically or logically prove that somebody is the owner of an IP (it can be spoofed), an indirect solution is required. It was considered that the certificate process of domains could be applied to IPs: There are Certificate Authorities (CA) who verify and validate the ownership of a domain.

CAs need to make investments in establishing a system that securely validates a domain and manages the certificates that are issued. CAs need to fulfill a wide range of requirements \cite{BaselineRequirements} to be considered reputable and be included in the root key store of operating system and browser vendors. Nearly all CAs for domains issue certificates for a fee or need to generate revenue by sponsorships.

Although it is technically possible to issue an SSL certificate for an IP address, it is very uncommon. GlobalSign \cite{GlobalSign} is the only provider known to us that issues certificates for IP addresses, and requires that the IP is registered in the RIPE database.

The same system that currently exists for domain owner verification could be introduced by the industry for IP addresses verification, but is very complicated and defeats the purpose of using the blockchain as the original idea was to remove the need for additional infrastructure.

\section{Validating Smart contracts during development}
Developing a smart contract requires a compiler and a blockchain on which the developer can execute the smart contract. A compiler, such as solc \cite{Solc}, will warn about syntax errors and does not compile invalid Solidity code, indicating to the developer that there is an error in the code.

While compilers provide a first layer of assurance by only compiling valid contracts with valid syntax, it is still possible to write code with bugs and security vulnerabilities. As with any software, developers need a workflow which allows them to test their changes fast and efficiently.

The main Ethereum blockchain is unsuitable for validating the correctness of the code manually. There are significant costs to deploy a contract to the blockchain, also it is not capable of giving the developer immediate feedback because of transaction processing times. It is also frowned upon to use the main blockchain for testing purposes, as all network participants need to download all blocks.

This is not the case in the Testnet, which is a separate blockchain for testing purposes. Still, the Testnet is a globally shared blockchain and is not perfect for development. Instead, a test framework called \texttt{TestRPC} that makes it possible to set up a local blockchain for testing is used. Using \texttt{TestRPC}, it is possible to simulate deployments and transactions of smart contracts with no confirmation delay. Out of the box, \texttt{TestRPC} sets up multiple Ethereum accounts, making it simple to switch the message sender address and test whether the access control features of the developed smart contract are working as desired. This makes \texttt{TestRPC} the ideal blockchain for developing.

In addition to manual testing, the robustness should be validated by unit tests, just like in any other piece of software. This allows to automatically validate that all assertions are still true when a change is introduced to the contract. A robust contract should include unit tests validating that normal use of the contract features result in correct behavior, as well as tests for edge cases and abuse of the contract features.

Examples of cases that should be tested are: Calling a function without permission, calling a function more often than expected, calling a function with unexpected arguments, such as null arguments, wrong types or a big payload.

\texttt{TestRPC}, the \texttt{solc-js} compiler, and the \texttt{ava} testing framework to set up a test environment. Each test is completely atomic and independent from other ones, that means that for each test, a separate \texttt{TestRPC} blockchain is created and the scenario is run on it. After the test is finished, the blockchain and the accounts get destroyed.

The complete isolation of each test is good practice, as side-effects can be ruled out. With \texttt{ava}, the tests can be run in parallel, making it faster to run the whole test suite. However, there are many other generic test frameworks that work just as well and have their own advantages and disadvantages.

One interesting specialized framework is Truffle \cite{Truffle}, which provides helpers for developing and testing Solidity contracts. Truffle attempts to make the process described in this section easier and looks very promising, but is still in beta. For the reason that the framework is still very much in development and changing, a generic testing framework was used.

For real-world smart contract applications, testing is not enough, critical contracts should be audited by computer security professionals before being deployed. As the aim of this thesis is to document a proof-of-concept DDoS mitigation application, no audit will be conducted.

\section{Security considerations with Solidity}
Code vulnerabilities are more common in Ethereum than in other environments. The whole blockchain data is public, and serious contracts are made open source in order to create trust for the people who use it. Therefore applications are auditable and bugs are more likely to be found.

The application must also regulate itself and can in most cases not recover from an attack with an update.

In addition to that, the language Solidity aims to have a syntax similar to JavaScript and is therefore quite loose with enforcing the correct type. External static code analysis tools such as Solium \cite{Solium} do not yet have as many rules included as comparable tools for more mature languages.

In this section, some common mistakes that can lead to security exploits will be explained, partially taken from a list compiled by the co-founder of Ethereum \cite{ThinkingAboutSmartContractSecurity} and based on real-word vulnerabilities.

\subsection{Constructor naming exploit}
Simple human mistakes can lead to the contract being vulnerable. The 'Rubixi' contract has a different constructor name than contract name. Therefore the constructor does not get called on deployment, but can be called as a transaction. If done so, the caller of the transaction becomes the owner of the contract. Because of more unfortunate design of the contract, the bug became not immediately apparent and the Solidity contract was correct.

\input{snippets/rubixi.tex}

\subsection{Public data}
A misconception is that stored data can be made private on the blockchain. A rock-paper-scissor contract which people used for gambling turned out to have a trivial flaw where the first move could be seen - rock would have the value \texttt{0x60689557} and scissor and paper have a different one.

The main takeaway is that the stored IP addresses will be public (although maybe obfuscated) to everybody. Even attackers can determine the list of IPs that are blocked. The contract should be created in a way that minimises the usefulness for attackers, for example the pattern of the IPs should not make the way how IPs are being blocked predictable.

\subsection{Loops}
The section "Security Considerations" of the Solidity documentation warns about loops that have a non-fixed amount of iterations. With a high number of iterations, the block gas limit could be reached and according to the Solidity documentations "cause the complete contract to be stalled at a certain point".

In the reference contract, the function \texttt{blockIPv4()} has a loop whose amount of iterations are dependant of a transaction argument. The contract has to be tested with a big payload and a solution needs to be developed.

Furthermore, even for constant functions (which are executed locally and have no gas limit), there can be bugs. If, in the reference contract there would be a slight change:

\input{snippets/loop-bug.tex}

a bug would be introduced. \texttt{var} would be interpreted as \texttt{uint8}, if there are more than 255 entries in the \texttt{drop\_src\_ipv4} array, an overflow leading to an infinite loop would happen.
This bug can be avoided by disallowing \texttt{var} in the code or by being aware of the issue.

\subsection{Re-Entry bugs using .call()}

The \texttt{.call()} method in Solidity is dangerous as it can execute code from external contracts. This weakness was first exploited in the DAO smart contract, which had over 50 million USD stored in it. The takeaway from the incident is that \texttt{.call()} can call any public function, even the function from which it was called from, leading to recursion.
The following example is not safe:

\input{snippets/reentry-bug.tex}

For illustrating the vulnerability, consider that the balance of an account is 10 and that account calls the withdraw method. The account can execute arbitrary code when \texttt{msg.sender.call()} is called on line 3, so \texttt{withdraw()} can also be called again before line 4 of the above snippet is reached. An attacker could withdraw more than what its balance is. The vulnerability could be mitigated by using \texttt{.send()} instead of \texttt{.call()} in the example above.

\subsection{Call stack depth attack}

The call stack depth gets increased when a function calls another function, and if a function returns, the call stack depth gets decreased. A long call stack can be produced by excessive recursion. Solidity has a 1024 call stack depth limit - this means that Solidity could for example not compute the 1025th fibonacci number using recursion.

The deterministic depth limit of Solidity proves to be an attack vector. An attacker could craft a function that calls itself 1023 times and on the 1024th time calls another, vulnerable function, that stops execution as soon as a subfunction is called, because the maximum call stack size is reached. 

An attacker might force a function to only partially execute, which is a problem, if for example a withdraw function is composited of a subfunction that sends funds and a function that decreases the users balance.
The core development team of Ethereum wants to solve this problem on a language-level in EIP \#150 \cite{EIP150} soon, therefore it will not be further discussed here.
